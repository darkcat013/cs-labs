# Intro to Cryptography. Classical ciphers. Caesar cipher

## Course: Cryptography & Security

### Author: Viorel Noroc

----

## Theory

Cryptography is a branch of mathematics that deals with securing information,
also ensuring authentication and restricting access in an informational system.

Classic cryptography falls under the class of symmetric key cryptography and is cryptography
before the computer, hence the name pre-computational cryptography. In classic cryptography, algorithms were character-based and consisted of a series of elementary transformations
(substitutions and transpositions) of plaintext characters.

### Substitution ciphers

The substitution cipher is the cipher in which each character or group of
characters of the plaintext m is replaced by another character or group of characters in the ciphertext c,
decryption is done by applying reverse substitution on the encrypted text.

### Monoalphabetic substitution ciphers

Monoalphabetic substitution ciphers (monoalphabetic ciphers) are the ciphers in which each
plaintext character m is replaced by a corresponding ciphertext character c.
Representatives of this class are: the Caesar cipher, the Polybios cipher, etc.

### The Caesar Cipher

In this cipher, each letter of the plaintext is replaced by a new letter obtained by an alphabetical shift. The secret key k, which is the same for encryption as and
upon decryption, it consists of the number indicating the alphabetic displacement, i.e. $k \in \{1, 2, 3,…, n–1\}$, where n is the length of the alphabet. The encryption and decryption of the message with the Caesar cipher can be defined by the formulas
where x and y are the numeric representation of the respective plaintext character.

For example, for the plaintext $m=Caesar\ cipher$ and key $k = 7$ we get the ciphertext $c=Jhlzhy\ jpwoly$

Caesar's cipher is very easy to crack, so it is a very weak cipher. Thus, a cryptanalyst can get the plain text by trying all 25 keys.

### The Polybius Cipher

In the Polybius cipher, a separate encryption square is built for each alphabet, most often with the same number of columns and lines (but this is not a necessary condition). Square dimensions depend on the length n of the alphabet. To create the square, two integers are taken, the product of which is closest to n. The lines and columns are numbered. After this the letters of the alphabet are written in this box in their natural order. If there are not enough cells for the letters of the alphabet, 2 letters can be entered in a cell or a few letters can be omitted (usually with the lowest possible frequency). For the Latin alphabet, we can have Polibios 5×5 squares by placing I and J in the same square.

|||||||
|---|---|---|---|-----|---|
|   | m | o | u | s   | e |
| m | A | B | C | D   | E |
| u | F | G | H | I/J | K |
| s | L | M | N | O   | P |
| c | Q | R | S | T   | U |
| a | V | W | X | Y   | Z |

For example, with the table above, the plaintext VENI VIDI VICI is encrypted in

ma em us su ma su sm su ma su um su

The weak point of monoalphabetic encryption systems lies in the frequency of occurrence of characters in the text. If an encrypted text is long enough and the language in which the plaintext is written is known, the system can be broken through an attack based on the frequency of occurrence of letters.

### Polyalphabetic substitution ciphers

The difference between polyalphabetic and monoalphabetic ciphers consists in the fact that the substitution of a character varies in the text, depending on various parameters (position, context, etc.). This of course leads to a much larger number of possible keys. The first polyalphabetic encryption system is believed to have been created by Leon Battista in 1568. Some current applications still use such encryption systems.

### The Vigenere cipher

Like the Caesar cipher, the Vigenere cipher moves the letters, but unlike it, it cannot be easily broken into 26 combinations. The Vigenere cipher uses a multiple shift. The key is not made up of a single shift, but of several, being generated by several integers $k_{i}$, where $0 \le k_{i} \le 25$, if we take the Latin alphabet with 26 letters as a reference. Encryption is done as follows:

$c_i = m_i + k_i (mod\ 26)$

The key is usually a word, to be easier to remember and $k_i$ represents the position of the key letter in the alphabet.

Decryption for the Vigenere cipher is similar to encryption. The difference is that the key is subtracted from the ciphertext:

$m_i = c_i – k_i (mod\ 26)$

For example, for the plaintext $m=Per\ aspera\ ad\ astra$ and key $k = Super$ we get the ciphertext $c=Hyg\ ejhyhe\ rv\ uhxis$

The Vigenere cipher is a lot safer than the Caesar cipher for two reasons:

- the first reason is that the others do not know the length of the key;
- the second reason is that the number of possible solutions increases, for example, for the key length equal to 5, the number of combinations that would be necessary for the exhaustive search would be $26^5 = 11,881,376$.

### Homophonic ciphers

The homophonic ciphers are intermediate ciphers between mono and polyalphabetic systems. Its main purpose is to avoid the attack by the frequency of appearance of the characters. The idea used in these ciphers is the uniformization of frequencies of the appearance of the characters of the digit text (secondary alphabet), in order to make it difficult to cryptanalytic attacks. Thus, the letter A - with the highest frequency of occurrence in the primary alphabet - can be replaced for example with H, # or M.

### Polygraphic substitution

Polygraphic substitution is achieved by substituting blocks (polygrams) in the clear text instead of single letters, thus destroying the meaning, so useful in cryptanalysis, the frequencies of different characters.

In the case of the singular letters, the frequency of the letters in the number of the text is equal to the frequency of the corresponding letters in the clear text. This invariance of frequencies provides an amount of information sufficiently to the cryptanalyst to break the figure. To minimize the collateral information provided by the frequency of appearance of the letters, the number of $d$ groups (d-grams) was used. If a group of $d$ letters is substituted by another group of letters, the substitution is called polygraphic. The simplest polygraphic substitution is obtained for $d = 2$ when the $m_1m_2$ d-gram in the clear text is substituted with the $c_1c_2$ d-gram in the encrypted text.

### The Playfair cipher

A classic example for d-grams substitution is Playfair cipher.
||||||
|-----|---|---|---|---|
| P   | L | A | Y | F |
| I/J | R | B | C | D |
| E   | G | H | K | M |
| N   | O | Q | S | T |
| U   | V | W | X | Z |

The first letters in the above square (in general case - a rectangle) represent a keyword $k$ (the letters that are repeated are written once, in this example the key being $k= Playfair$), after which the square is completed with the letters of the alphabet in their natural order , without repetition. Then the encryption is executed according to the following rules:

- The plaintext is separated in d-grams (pairs of letters)

- A pair cannot have identical letter so for the separation of the identical letters, some separation characters are introduced which, as a rule, have a reduced occurrence frequency, such as the letter X. If the number of characters in the plaintext is odd, such a letter is added at the end of it. When deciphering, these added letters are omitted.

- If $m_1$ and $m_2$ are in the same column in the above square then $c_1$ and $c_2$ are obtained by a cyclical displacement of $m_1$ and $m_2$ from top to bottom. For example AH → BQ and OV → VL;

- If $m_1$ and $m_2$ are in the same row, then $c_1$ and $c_2$ are obtained by a cyclical movement to the right of the letters $m_1$ and $m_2$. For example PA → LY and NO → OQ;

- If $m_1$ and $m_2$ are not in the same line or column, then $c_1$ and $c_2$ are the characters in the intersection of the line and columns. For example RK → CG and PZ → FU;

The deciphering is executed according to the rules similar to those of encryption, reversing the direction.

Using the example above ($k = Playfair$) for the clear text m = "Hello world" we obtain the encrypted text $c = KG\ YV\ RV\ VQ\ GR\ CZ$. Here we introduced between letters $ll$ the letter X and an extra letter X at the end because the amount of characters of the plaintext in this case becomes odd. When deciphering according to the meaning of the message, the letter X is omitted.

The use of the Playfair cipher currently does not make sense because modern laptops can easily break the cipher in seconds.
## Objectives

1. Get familiar with the basics of cryptography and classical ciphers.

2. Implement 4 types of the classical ciphers:
    - Caesar cipher,
    - Polybius cipher,
    - Vigenere cipher,
    - Playfair cipher.

3. Structure the project in methods/classes/packages as neeeded.

## Implementation description

All the ciphers in this laboratory work implement the Cipher interface in the interfaces directory. Some tests for each cipher are also provided.

### Caesar cipher

This is the simplest one to implement, just get the position of the letter of the plaintext in alphabet by subtracting it's ASCII code with the ASCII code of letter A and use the formula for the Caesar cipher.

```go
letterPos := int(s[i]) - constants.ASCII_A
encPos := (letterPos + c.Key) % constants.ALPHABET_LEN
enc += string(constants.ALPHABET[encPos])
```
For decryption, replace the addition with subtraction and make sure the mod operation to not give negative result by adding the length of the alphabet of it.

```go
letterPos := int(s[i]) - constants.ASCII_A
decPos := (letterPos - c.Key + constants.ALPHABET_LEN) % constants.ALPHABET_LEN
dec += string(constants.ALPHABET[decPos])
```

### Polybius cipher

This cipher gets two words as input, the key for the columns and the key for the rows in the table above. For the encryption, each letter of the plaintext is replaced with 2 letters, column letter and row letter. 

```go
val := string(p.ColumnKey[letterPos%5]) + string(p.RowKey[letterPos/5])
enc += string(val)
```

For the decryption, each pair of letters is replaced with the matching letter in the table, by using the first letter as the column and the second letter as the row.

```go
dec += string(matrix[s[i+1]][s[i]])
```

### Vigenere cipher

This cipher is similar to the Caesar cipher in implementation but instead of having a fixed key, the key is a word and each letter has its position in alphabet, so use that position instead of the fixed key in the Caesar cipher. Be careful to start over each time the end of the key word is reached (using mod operator).

```go
letterPos := int(s[i]) - constants.ASCII_A
keyLetterPos := int(c.Key[i%len(c.Key)]) - constants.ASCII_A
encPos := (letterPos + keyLetterPos) % constants.ALPHABET_LEN
enc += string(constants.ALPHABET[encPos])
```

For the decryption, use the same logic as with Caesar, replace the addition with subtraction and make sure the result of the mod to not be negative

```go
letterPos := int(s[i]) - constants.ASCII_A
keyLetterPos := int(c.Key[i%len(c.Key)]) - constants.ASCII_A
decPos := (letterPos - keyLetterPos + constants.ALPHABET_LEN) % constants.ALPHABET_LEN
dec += string(constants.ALPHABET[decPos])
```

### Playfair cipher

At first, the square with the alphabet and the key needs to be generated, remove the current key letter from the alphabet and add the letters from the key(starting from the end) to the alphabet:

```go
for i := len(pf.Key) - 1; i >= 0; i-- {
	newAlpha = string(pf.Key[i]) 
        + strings.ReplaceAll(newAlpha, string(pf.Key[i]), "")
}
newAlpha = strings.ReplaceAll(newAlpha, "J", "")
```

For encryption, take each pair of letters and follow the cipher's algorithm, in this case it is done in the encryptDigraph function. Also add an additional letter if the letters in the pair are the same and add a letter in the end if the plaintext has an odd amount of characters.

```go
if i+1 == len(s) {
	s += constants.RARE_LETTER
	enc += encryptDigraph(newAlpha, s[i], s[i+1]) + " "
	break
}

if s[i] == s[i+1] {
	s = s[:i+1] + constants.RARE_LETTER + s[i+1:]
}
enc += encryptDigraph(newAlpha, s[i], s[i+1]) + " "
```

For decryption, just do the encryption in the reverse order, in this case it is done in decryptDigraph function.

```go
dec += decryptDigraph(newAlpha, s[i], s[i+1])
```

## Conclusions

In conclusion, this laboratory work was a pretty simple and interesting one. Even if I knew some classical ciphers before doing this laboratory work, it allowed me to dive deeper into the theory behind them and ultimately making my knowledge foundation stronger.